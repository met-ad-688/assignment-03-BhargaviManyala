---
title: Assignment 03
author:
  - name: Bhargavi Manyala
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: today
format:
  html:
    theme: cerulean
    toc: true
    toc-depth: 2
  pdf: 
    fig-format: png
    embed-resources: true
    toc-depth: 2
    geometry: 
      - landscape
      - margin=0.5in
    
date-modified: today
date-format: long
jupyter: assignment03-venv
execute:
  echo: true
  eval: true
  output: true
  freeze: auto
---


# Import Dataset


```{python}


import pandas as pd
import plotly.express as px
import plotly.io as pio
from pyspark.sql import SparkSession
import re
import numpy as np
import plotly.graph_objects as go
from pyspark.sql.functions import col, split, explode, regexp_replace, transform, when
from pyspark.sql import functions as F
from pyspark.sql.functions import col, monotonically_increasing_id

np.random.seed(42)
#pio.renderers.default = "vscode+notebook+svg"
 
spark = SparkSession.builder.appName("LightcastData").getOrCreate()
df = (
    spark.read
    .option("header", "true")
    .option("inferSchema", "true")
    .option("multiLine", "true")
    .option("escape", "\"")  
    .csv("lightcast_job_postings.csv")
)

df.createOrReplaceTempView("job_postings")
#df.show(5)



```



#  Casting salary and experience columns

## Computing medians and Imputing missing salaries
```{python}

from pyspark.sql.functions import col

df = df.withColumn("SALARY", col("SALARY").cast("float")) \
       .withColumn("SALARY_FROM", col("SALARY_FROM").cast("float")) \
       .withColumn("SALARY_TO", col("SALARY_TO").cast("float")) \
       .withColumn("MIN_YEARS_EXPERIENCE", col("MIN_YEARS_EXPERIENCE").cast("float")) \
       .withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float"))

# Computing medians for salary columns
def compute_median(sdf, col_name):
    return sdf.approxQuantile(col_name, [0.5], 0.01)[0]

median_from = compute_median(df, "SALARY_FROM")
median_to   = compute_median(df, "SALARY_TO")
median_salary = compute_median(df, "SALARY")

print("Medians:", median_from, median_to, median_salary)

# Imputing missing salaries, but not experience
df = df.fillna({
    "SALARY_FROM": median_from,
    "SALARY_TO": median_to
})

# Computing average salary
df = df.withColumn(
    "Average_Salary", (col("SALARY_FROM") + col("SALARY_TO")) / 2
)

# Selecting required columns
export_cols = [
    "Average_Salary",
    "SALARY",
    "EDUCATION_LEVELS_NAME",
    "REMOTE_TYPE_NAME",
    "MAX_YEARS_EXPERIENCE",
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME"
]

df_selected = df.select(*export_cols)

pdf_selected = df_selected.toPandas()
pdf_selected.head()

```

## Cleaning Education column and  Exporting Cleaned Data

*I referred to Claude Sonnet 4 for prompts and sample code ideas, but I wrote and adapted the final implementation myself

```{python}
# To remove \n and \r
pdf_selected["EDUCATION_LEVELS_NAME"] = (
    pdf_selected["EDUCATION_LEVELS_NAME"]
    .astype(str)               
    .str.replace(r"[\n\r]", "", regex=True)
    .str.strip()                
)
pdf_selected.to_csv("data/lightcast_cleaned.csv", index=False)
pdf_selected.head()
```

## Exporting Cleaned Data

```{python}
print("Data cleaning complete. Rows retained:", len(pdf_selected))

```

# Salary Distribution by Industry and Employment Type

## Salary Distribution by Employment Type
```{python}

pdf = df.select(
    "EMPLOYMENT_TYPE_NAME",
    "NAICS2_NAME",
    "SALARY"
).toPandas()


pdf = pdf[pdf["SALARY"] > 0]

pdf["EMPLOYMENT_TYPE_NAME"] = (
    pdf["EMPLOYMENT_TYPE_NAME"]
    .astype(str) 
    .apply(lambda x: re.sub(r"[^\x00-\x7F]+", "", x)) 
    .str.strip()  
)

median_salaries = pdf.groupby("EMPLOYMENT_TYPE_NAME")["SALARY"].median()

sorted_employment_types = median_salaries.sort_values(ascending=False).index

pdf["EMPLOYMENT_TYPE_NAME"] = pd.Categorical(
    pdf["EMPLOYMENT_TYPE_NAME"],
    categories=sorted_employment_types,
    ordered=True
)

```

```{python}

fig = px.box(
    pdf,
    x="EMPLOYMENT_TYPE_NAME",
    y="SALARY",
    title="Salary Distribution by Employment Type",
    color_discrete_sequence=["#CC0000"],  
    boxmode="group",
    points="outliers" 
)


fig.update_layout(
    xaxis=dict(
        title=dict(
            text="Employment Type",
            font=dict(size=14, family="Arial Black", color="black")  
        ),
        tickangle=-45,
        tickfont=dict(size=12, family="Arial Black", color="black"),    
        categoryorder="array",
        categoryarray=sorted_employment_types.tolist() 
    ),
    yaxis=dict(
        title=dict(
            text="Salary (1000 $)",
            font=dict(size=14, family="Arial Black", color="black")  
        ),
        tickvals=[0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000, 450000, 500000],
        ticktext=["0", "50k", "100k", "150k", "200k", "250k", "300k", "350k", "400k", "450k", "500k"],
        tickfont=dict(size=12, family="Arial Black", color="black"),              
    ),
    font=dict(family="Arial", size=16, color="black"),
    boxgap=0.7,
    showlegend=False,
    height=500,
    width=850,
)




fig.write_html("./output/Q1.html")
fig.write_image("./output/Q1.png", width = 850, height = 500, scale=1)
```

![](./output/Q1.png)

### Interpretation
* The boxplot indicates that full-time employees (>32 hours) receive higher median salaries with greater variability.
* In contrast, part-time employees indicates lower and more consistent salary ranges, with occasional high outliers

## Salary Distribution by Industry

```{python}


pdf = df.select(
    "NAICS2_NAME",
    "SALARY"
).toPandas()



fig = px.box(
    pdf,
    x="NAICS2_NAME",
    y="SALARY",
    title="Salary Distribution by Industry",
    color_discrete_sequence=["#CC0000"],  
    points="outliers"
)


fig.update_layout(
    height=500,
    font_family="Arial",
    title_font_size=16,
    xaxis_title="NAICS2_NAME",
    yaxis_title="Salary",
    xaxis_tickangle=45,
    
)


fig.write_html("./output/Q2.html")
fig.write_image("./output/Q2.png", width=1000, height=600, scale=1)


```

![](./output/Q2.png)

### Interpretation
* The boxplot indicates that salary levels differ across industries, with Information, Finance, and Professional Services showing higher median salaries.
*Education and Public Admiration have lower median salaries with narrower ranges.
* Most industries center around $100k, though some display wider variation and notable outliers.

# Salary Analysis by ONET Occupation Type (Bubble Chart)

```{python}
salary_analysis = spark.sql("""
SELECT
    LOT_OCCUPATION_NAME AS Occupation_Name,
    PERCENTILE(SALARY, 0.5) AS Median_Salary,
    COUNT(*) AS Job_Postings
FROM job_postings
GROUP BY LOT_OCCUPATION_NAME
ORDER BY Job_Postings DESC
LIMIT 10
""")

salary_pd = salary_analysis.toPandas()
salary_pd.head()
```

```{python}

fig = px.scatter(
   salary_pd,
   x="Occupation_Name",
   y="Median_Salary",
   size="Job_Postings",
   title="Salary Analysis by LOT Occupation Type (Bubble Chart)",
   labels={
       "Occupation_Name": "LOT Occupation",
       "Median_Salary": "Median Salary",
       "Job_Postings": "Number of Job Postings",
   },
   hover_name="Occupation_Name",
   size_max=60,
   width=900,
   height=800,
   color="Job_Postings",
   color_continuous_scale="Plasma",
)

fig.update_layout(
   font_family="Arial",
   font_size=14,
   title_font_size=22,
   xaxis_title="LOT Occupation",
   yaxis_title="Median Salary",
   plot_bgcolor="white",
   xaxis=dict(
       tickangle=-45,
       showline=True,
       linecolor="black",
   ),
   yaxis=dict(
       showline=True,
       linecolor="black",
   ),
)

fig.write_html("./output/Q3.html")
fig.write_image("./output/Q3.png", width=900, height=800, scale=1)

```

![](./output/Q3.png)

### Interpretation
